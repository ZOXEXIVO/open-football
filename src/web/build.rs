use std::collections::hash_map::DefaultHasher;
use std::env;
use std::fs;
use std::hash::{Hash, Hasher};
use std::path::Path;

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let out_dir = env::var("OUT_DIR").unwrap();

    let css_dir = Path::new(&manifest_dir).join("assets").join("css");
    let output_file = Path::new(&manifest_dir).join("assets").join("css").join("styles.min.css");

    // Watch for changes in CSS directory (use absolute path)
    println!("cargo:rerun-if-changed={}", css_dir.display());
    // Also watch the build script itself
    println!("cargo:rerun-if-changed={}", Path::new(&manifest_dir).join("build.rs").display());

    // Check if minification is enabled (release builds or explicit feature)
    let minify = env::var("PROFILE").map(|p| p == "release").unwrap_or(false)
        || env::var("CARGO_FEATURE_MINIFY_CSS").is_ok();

    // Define CSS files to bundle (in order)
    // Note: flags.css is excluded as it's already minified and very large (2.7MB)
    let css_files = [
        "style.css",
        "images.css"
    ];

    let mut combined_css = String::new();

    // Add a header comment
    combined_css.push_str("/* Combined and ");
    if minify {
        combined_css.push_str("minified ");
    }
    combined_css.push_str("CSS - Generated by build.rs */\n");

    for file_name in &css_files {
        let file_path = css_dir.join(file_name);

        if file_path.exists() {
            // Watch individual CSS files with absolute paths
            println!("cargo:rerun-if-changed={}", file_path.display());

            match fs::read_to_string(&file_path) {
                Ok(content) => {
                    // Add file separator comment (only in non-minified mode)
                    if !minify {
                        combined_css.push_str(&format!("\n/* === {} === */\n", file_name));
                    }

                    let processed = if minify {
                        minify_css(&content)
                    } else {
                        content
                    };

                    combined_css.push_str(&processed);
                    combined_css.push('\n');
                }
                Err(e) => {
                    println!("cargo:warning=Failed to read {}: {}", file_name, e);
                }
            }
        } else {
            println!("cargo:warning=CSS file not found: {}", file_path.display());
        }
    }

    // Write the combined CSS file
    if let Err(e) = fs::write(&output_file, &combined_css) {
        println!("cargo:warning=Failed to write combined CSS: {}", e);
    } else {
        println!("cargo:warning=Generated {} ({} bytes, minified: {})",
            output_file.display(),
            combined_css.len(),
            minify
        );
    }

    // Generate a hash of the CSS content to force recompilation when CSS changes
    // This is necessary because rust-embed embeds files at compile time
    let mut hasher = DefaultHasher::new();
    combined_css.hash(&mut hasher);
    let css_hash = hasher.finish();

    // Write a Rust file with the hash that can be included to force recompilation
    let hash_file = Path::new(&out_dir).join("css_hash.rs");
    let hash_content = format!(
        "// Auto-generated by build.rs - DO NOT EDIT\n\
         #[allow(dead_code)]\n\
         const CSS_BUILD_HASH: u64 = {};\n",
        css_hash
    );
    fs::write(&hash_file, hash_content).expect("Failed to write css_hash.rs");
}

/// Simple CSS minification function
/// Removes comments, unnecessary whitespace, and newlines
fn minify_css(css: &str) -> String {
    let mut result = String::with_capacity(css.len());
    let mut chars = css.chars().peekable();
    let mut in_string = false;
    let mut string_char = '"';
    let mut last_char = ' ';

    while let Some(c) = chars.next() {
        // Handle string literals
        if !in_string && (c == '"' || c == '\'') {
            in_string = true;
            string_char = c;
            result.push(c);
            continue;
        }

        if in_string {
            result.push(c);
            if c == string_char && last_char != '\\' {
                in_string = false;
            }
            last_char = c;
            continue;
        }

        // Remove comments
        if c == '/' && chars.peek() == Some(&'*') {
            chars.next(); // consume '*'
            // Skip until */
            while let Some(cc) = chars.next() {
                if cc == '*' && chars.peek() == Some(&'/') {
                    chars.next(); // consume '/'
                    break;
                }
            }
            continue;
        }

        // Handle whitespace
        if c.is_whitespace() {
            // Collapse multiple whitespace to single space
            // Skip whitespace after certain characters
            let skip_after = ['{', '}', ';', ':', ',', '>', '+', '~', '(', ')'];
            let skip_before = ['{', '}', ';', ':', ',', '>', '+', '~', '(', ')'];

            if !skip_after.contains(&last_char) {
                // Check if next non-whitespace needs space
                while chars.peek().map(|c| c.is_whitespace()).unwrap_or(false) {
                    chars.next();
                }

                if let Some(&next) = chars.peek() {
                    if !skip_before.contains(&next) && !result.is_empty() {
                        result.push(' ');
                        last_char = ' ';
                    }
                }
            } else {
                // Skip whitespace after special chars
                while chars.peek().map(|c| c.is_whitespace()).unwrap_or(false) {
                    chars.next();
                }
            }
            continue;
        }

        result.push(c);
        last_char = c;
    }

    // Additional cleanup passes
    let result = result
        .replace(" {", "{")
        .replace("{ ", "{")
        .replace(" }", "}")
        .replace("} ", "}")
        .replace(": ", ":")
        .replace(" :", ":")
        .replace("; ", ";")
        .replace(" ;", ";")
        .replace(", ", ",")
        .replace(" ,", ",")
        .replace("  ", " ");

    result.trim().to_string()
}
