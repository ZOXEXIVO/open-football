{% extends "layout.html" %}

{% block content %}
<div class="fm-page fm-match-page">
    <div class="container-fluid">
        <div class="row">
            <div class="col-lg-2 d-none d-lg-block">
                <div class="fm-match-squad fm-match-squad-home">
                    <a href="/teams/{{ home_team_slug }}" class="fm-squad-title">{{ home_team_name }}</a>
                    <div class="fm-squad-section">
                        {% for player in home_squad_main %}
                        <a href="/teams/{{ home_team_slug }}/players/{{ player.id }}" class="fm-squad-player">
                            {{ player.last_name }} {{ player.first_name }}
                            <small>{{ player.position }}</small>
                        </a>
                        {% endfor %}
                    </div>
                    <div class="fm-squad-divider">Substitutes</div>
                    <div class="fm-squad-section">
                        {% for player in home_squad_subs %}
                        <a href="/teams/{{ home_team_slug }}/players/{{ player.id }}" class="fm-squad-player">
                            {{ player.last_name }} {{ player.first_name }}
                            <small>{{ player.position }}</small>
                        </a>
                        {% endfor %}
                    </div>
                </div>
            </div>
            <div class="col-lg-8">
                <div id="match-play-area">
                    <div class="time-scrollbar-wrapper" id="time-scrollbar-wrapper" style="display:none">
                        <div class="time-scrollbar-container">
                            <div class="half-labels">
                                <span class="half-label">1st Half</span>
                                <span class="half-label">2nd Half</span>
                            </div>
                            <div class="time-scrollbar-track" id="time-scrollbar-track">
                                <div class="halftime-delimiter" style="left:50%">
                                    <div class="delimiter-line"></div>
                                    <div class="delimiter-label">HT</div>
                                </div>
                                <div id="goal-markers"></div>
                                <div class="time-progress" id="time-progress"></div>
                                <div class="time-scrollbar-slider" id="time-slider">
                                    <div class="time-display" id="time-display">0:00</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="match-container">
                        <div class="loading-spinner" id="loading-spinner">
                            <i class="fas fa-spinner fa-spin fa-2x"></i>
                            <p>Loading match data...</p>
                        </div>
                        <div id="pixi-container" class="match-container"></div>
                    </div>
                </div>
            </div>
            <div class="col-lg-2 d-none d-lg-block">
                <div class="fm-match-squad fm-match-squad-away">
                    <a href="/teams/{{ away_team_slug }}" class="fm-squad-title">{{ away_team_name }}</a>
                    <div class="fm-squad-section">
                        {% for player in away_squad_main %}
                        <a href="/teams/{{ away_team_slug }}/players/{{ player.id }}" class="fm-squad-player">
                            {{ player.last_name }} {{ player.first_name }}
                            <small>{{ player.position }}</small>
                        </a>
                        {% endfor %}
                    </div>
                    <div class="fm-squad-divider">Substitutes</div>
                    <div class="fm-squad-section">
                        {% for player in away_squad_subs %}
                        <a href="/teams/{{ away_team_slug }}/players/{{ player.id }}" class="fm-squad-player">
                            {{ player.last_name }} {{ player.first_name }}
                            <small>{{ player.position }}</small>
                        </a>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="/js/pixi.min.js"></script>
<script>
(function() {
    const leagueSlug = "{{ league_slug }}";
    const matchId = "{{ match_id }}";
    const matchTimeMsTotal = {{ match_time_ms }};
    const goalsData = {{ goals_json|safe }};
    const playersData = {{ players_json|safe }};

    const maxWidth = 1400;
    const maxHeight = 950;
    const aspectRatio = 16 / 10;

    let app = null;
    let background = null;
    let gameContainer = null;
    let currentTime = 0;
    let isPlaying = false;
    let lastTickTime = 0;
    let ballData = [];
    let playerPositions = {};
    let playerGraphics = {};
    let playerIds = [];
    let ballObj = null;
    let loadedChunks = new Set();
    let loadingChunks = new Set();
    let totalChunks = 0;
    let chunkDurationMs = 300000;
    let isDragging = false;

    // Debug event logging
    let eventData = [];
    let lastEventIdx = 0;

    // Cached DOM elements (set once in init)
    let sliderEl = null;
    let progressEl = null;
    let displayEl = null;

    // Temporal coherence: remember last search index per entity
    let lastBallIdx = 0;
    let lastPlayerIdx = {};

    // Frame throttle for 30fps
    const TARGET_FPS = 30;
    const FRAME_INTERVAL = 1000 / TARGET_FPS;
    let lastFrameTime = 0;

    const fieldWidth = 840;
    const fieldHeight = 545;
    // Field rectangle within the 1400x950 SVG canvas
    const fieldOffsetX = 62;
    const fieldOffsetY = 60;
    const fieldPixelW = 1260;
    const fieldPixelH = 810;

    // Precomputed scale factors
    const scaleX = fieldPixelW / fieldWidth;
    const scaleY = fieldPixelH / fieldHeight;

    function translateToField(x, y) {
        return { x: x * scaleX + fieldOffsetX, y: y * scaleY + fieldOffsetY };
    }

    function getChunkNumber(time) {
        return Math.floor(time / chunkDurationMs);
    }

    async function loadChunk(chunkNum) {
        if (!Number.isFinite(chunkNum) || loadedChunks.has(chunkNum) || loadingChunks.has(chunkNum) || chunkNum < 0 || chunkNum >= totalChunks) return;
        loadingChunks.add(chunkNum);
        try {
            const res = await fetch(`/api/match/${leagueSlug}/${matchId}/chunk/${chunkNum}`);
            const data = await res.json();
            mergeData(data, chunkNum);
            loadedChunks.add(chunkNum);
        } finally {
            loadingChunks.delete(chunkNum);
        }
    }

    function mergeSorted(existing, incoming) {
        if (existing.length === 0) return incoming;
        // Chunks arrive in order, so incoming timestamps are usually all after existing
        if (incoming.length > 0 && incoming[0].timestamp >= existing[existing.length - 1].timestamp) {
            return existing.concat(incoming);
        }
        // Fallback: full merge for out-of-order loads
        const merged = new Array(existing.length + incoming.length);
        let i = 0, j = 0, k = 0;
        while (i < existing.length && j < incoming.length) {
            if (existing[i].timestamp <= incoming[j].timestamp) merged[k++] = existing[i++];
            else merged[k++] = incoming[j++];
        }
        while (i < existing.length) merged[k++] = existing[i++];
        while (j < incoming.length) merged[k++] = incoming[j++];
        return merged;
    }

    function mergeData(data, chunkNum) {
        if (data.ball) {
            ballData = mergeSorted(ballData, data.ball);
        }
        if (data.players) {
            const entries = Object.entries(data.players);
            for (let i = 0; i < entries.length; i++) {
                const id = entries[i][0];
                const positions = entries[i][1];
                if (!playerPositions[id]) {
                    playerPositions[id] = positions;
                } else {
                    playerPositions[id] = mergeSorted(playerPositions[id], positions);
                }
            }
        }
        if (data.events && data.events.length > 0) {
            eventData = mergeSorted(eventData, data.events);
        }
    }

    function findIndexNear(arr, time, hint) {
        const len = arr.length;
        if (len === 0) return -1;
        // Try hint and nearby (temporal coherence - usually advances by 1-2)
        if (hint >= 0 && hint < len) {
            if (arr[hint].timestamp <= time) {
                // Scan forward from hint
                let i = hint;
                while (i + 1 < len && arr[i + 1].timestamp <= time) i++;
                return i;
            } else {
                // Scan backward a bit
                let i = hint - 1;
                while (i >= 0 && arr[i].timestamp > time) i--;
                return Math.max(i, 0);
            }
        }
        // Fallback: binary search
        let lo = 0, hi = len - 1;
        while (lo < hi) {
            const mid = (lo + hi + 1) >> 1;
            if (arr[mid].timestamp <= time) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }

    function interpolatePosition(arr, idx, time) {
        const a = arr[idx];
        if (idx + 1 < arr.length) {
            const b = arr[idx + 1];
            const dt = b.timestamp - a.timestamp;
            if (dt > 0) {
                const t = (time - a.timestamp) / dt;
                return [
                    a.position[0] + (b.position[0] - a.position[0]) * t,
                    a.position[1] + (b.position[1] - a.position[1]) * t,
                    (a.position[2] || 0) + ((b.position[2] || 0) - (a.position[2] || 0)) * t
                ];
            }
        }
        return a.position;
    }

    function updatePositions(time) {
        lastBallIdx = findIndexNear(ballData, time, lastBallIdx);
        if (lastBallIdx >= 0 && ballObj) {
            const pos3 = interpolatePosition(ballData, lastBallIdx, time);
            const z = pos3[2] || 0;
            const pos = translateToField(pos3[0], pos3[1]);
            ballObj.position.x = pos.x;
            ballObj.position.y = pos.y;
            const heightScale = 1.0 + Math.min(z / 15.0, 0.4);
            ballObj.scale.set(heightScale);
        }

        for (let i = 0; i < playerIds.length; i++) {
            const id = playerIds[i];
            const positions = playerPositions[id];
            const gfx = playerGraphics[id];
            if (!positions || !gfx) continue;
            const hint = lastPlayerIdx[id] || 0;
            const pi = findIndexNear(positions, time, hint);
            lastPlayerIdx[id] = pi;
            if (pi >= 0) {
                const pos3 = interpolatePosition(positions, pi, time);
                const pos = translateToField(pos3[0], pos3[1]);
                gfx.position.x = pos.x - 10;
                gfx.position.y = pos.y - 10;
            }
        }
    }

    function formatMatchTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const halfDuration = matchTimeMsTotal / 2;
        if (ms < halfDuration) {
            return minutes + ':' + String(seconds).padStart(2, '0') + ' (1st)';
        } else {
            const s2 = Math.floor((ms - halfDuration) / 1000);
            const m2 = Math.floor(s2 / 60);
            const sec2 = s2 % 60;
            return m2 + ':' + String(sec2).padStart(2, '0') + ' (2nd)';
        }
    }

    function logEvents(time) {
        while (lastEventIdx < eventData.length && eventData[lastEventIdx].timestamp <= time) {
            const evt = eventData[lastEventIdx];
            const timeStr = formatMatchTime(evt.timestamp);
            if (evt.category === 'ball') {
                console.log(`%c[${timeStr}] Ball: ${evt.description}`, 'color: #4fc3f7');
            } else {
                console.log(`%c[${timeStr}] Player: ${evt.description}`, 'color: #81c784');
            }
            lastEventIdx++;
        }
    }

    function updateSlider() {
        if (matchTimeMsTotal <= 0) return;
        const pct = (currentTime / matchTimeMsTotal) * 100;
        sliderEl.style.left = pct + '%';
        progressEl.style.width = pct + '%';
        displayEl.textContent = formatMatchTime(currentTime);
    }

    function tick(now) {
        if (!isPlaying) return;

        // Throttle to target FPS
        const elapsed = now - lastFrameTime;
        if (elapsed < FRAME_INTERVAL) return;
        lastFrameTime = now - (elapsed % FRAME_INTERVAL);

        if (lastTickTime === 0) lastTickTime = now;
        const delta = now - lastTickTime;
        lastTickTime = now;
        currentTime += delta;

        if (currentTime >= matchTimeMsTotal) {
            currentTime = matchTimeMsTotal;
            isPlaying = false;
        }

        // Preload current + next chunk
        const chunkNeeded = getChunkNumber(currentTime);
        if (!loadedChunks.has(chunkNeeded)) loadChunk(chunkNeeded);
        const nextChunk = chunkNeeded + 1;
        if (nextChunk < totalChunks && !loadedChunks.has(nextChunk)) loadChunk(nextChunk);

        updatePositions(currentTime);
        logEvents(currentTime);
        if (!isDragging) updateSlider();
    }

    function getPlayerColor(player) {
        if (player.position === 'GK') return 0xf7e300;
        return player.is_home ? 0x00307d : 0xb33f00;
    }

    function createPlayerGraphic(x, y, player) {
        const container = new PIXI.Container();
        container.position.x = x - 10;
        container.position.y = y - 10;

        const color = getPlayerColor(player);
        const borderColor = color === 0xf7e300 ? 0x000000 : 0xffffff;

        const border = new PIXI.Graphics();
        border.circle(6, 6, 19).fill(borderColor);
        container.addChild(border);

        const circle = new PIXI.Graphics();
        circle.circle(6, 6, 16).fill(color);
        container.addChild(circle);

        const numStyle = new PIXI.TextStyle({
            fontFamily: 'Arial, sans-serif',
            fontSize: 14,
            fontWeight: 'bold',
            fill: player.position === 'GK' ? 'black' : 'white',
            align: 'center'
        });
        const numText = new PIXI.Text({text: String(player.shirt_number), style: numStyle});
        numText.anchor.set(0.5);
        numText.position.set(6, 6);
        container.addChild(numText);

        const nameStyle = new PIXI.TextStyle({
            fontFamily: 'Verdana, sans-serif',
            fontSize: 17,
            fill: 'white',
            wordWrap: false,
            align: 'center'
        });
        const nameText = new PIXI.Text({text: player.last_name, style: nameStyle});
        nameText.x = 10;
        nameText.y = 40;
        nameText.anchor.set(0.5);
        container.addChild(nameText);

        return container;
    }

    async function init() {
        let metadata;
        try {
            const metaRes = await fetch(`/api/match/${leagueSlug}/${matchId}/metadata`);
            if (!metaRes.ok) throw new Error(`metadata response ${metaRes.status}`);
            metadata = await metaRes.json();
        } catch(e) {
            console.error('Failed to load metadata:', e);
            document.getElementById('loading-spinner').innerHTML = '<p>Failed to load match data</p>';
            return;
        }

        totalChunks = metadata.chunk_count || 0;
        chunkDurationMs = metadata.chunk_duration_ms || 300000;

        const chunkRes = await fetch(`/api/match/${leagueSlug}/${matchId}/chunk/0`);
        const firstChunk = await chunkRes.json();
        mergeData(firstChunk, 0);
        loadedChunks.add(0);

        app = new PIXI.Application();
        await app.init({
            antialias: true,
            autoDensity: true,
            resolution: window.devicePixelRatio,
            width: maxWidth,
            height: maxHeight,
            backgroundColor: 0x283238
        });

        const container = document.getElementById('pixi-container');
        container.appendChild(app.canvas);

        const bgTexture = await PIXI.Assets.load('/images/match/field.svg');
        background = new PIXI.Sprite(bgTexture);
        background.width = maxWidth;
        background.height = maxHeight;
        app.stage.addChild(background);

        gameContainer = new PIXI.Container();
        app.stage.addChild(gameContainer);

        // Build a lookup map for players by id
        const playerMap = {};
        for (let i = 0; i < playersData.length; i++) playerMap[playersData[i].id] = playersData[i];

        const chunkPlayers = Object.entries(firstChunk.players || {});
        for (let i = 0; i < chunkPlayers.length; i++) {
            const id = chunkPlayers[i][0];
            const positions = chunkPlayers[i][1];
            const player = playerMap[Number(id)];
            if (player && positions.length > 0) {
                const pos = translateToField(positions[0].position[0], positions[0].position[1]);
                const gfx = createPlayerGraphic(pos.x, pos.y, player);
                playerGraphics[id] = gfx;
                playerIds.push(id);
                gameContainer.addChild(gfx);
            }
        }

        const ballContainer = new PIXI.Container();
        const ballCircle = new PIXI.Graphics();
        ballCircle.circle(0, 0, 6).fill(0xFFFFFF);
        ballCircle.circle(0, 0, 6).stroke({width: 2, color: 0x000000});
        ballContainer.addChild(ballCircle);
        if (firstChunk.ball && firstChunk.ball.length > 0) {
            const bp = translateToField(firstChunk.ball[0].position[0], firstChunk.ball[0].position[1]);
            ballContainer.position.x = bp.x;
            ballContainer.position.y = bp.y;
        }
        gameContainer.addChild(ballContainer);
        ballObj = ballContainer;

        resizeApp();
        window.addEventListener('resize', resizeApp);

        document.getElementById('loading-spinner').style.display = 'none';
        document.getElementById('time-scrollbar-wrapper').style.display = 'block';

        const markersDiv = document.getElementById('goal-markers');
        goalsData.forEach(goal => {
            const pct = (goal.time / matchTimeMsTotal) * 100;
            const player = playersData.find(p => p.id === goal.player_id);
            const isHome = player ? player.is_home : true;
            const marker = document.createElement('div');
            marker.className = 'goal-marker ' + (isHome ? 'goal-marker-home' : 'goal-marker-away');
            marker.style.left = pct + '%';
            marker.innerHTML = '<div class="goal-icon">\u26BD</div>';
            markersDiv.appendChild(marker);
        });

        document.getElementById('time-scrollbar-track').addEventListener('mousedown', async (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            currentTime = pct * matchTimeMsTotal;
            lastEventIdx = 0;
            await loadChunk(getChunkNumber(currentTime));
            updatePositions(currentTime);
            updateSlider();
        });

        // Cache DOM elements for slider updates
        sliderEl = document.getElementById('time-slider');
        progressEl = document.getElementById('time-progress');
        displayEl = document.getElementById('time-display');

        isPlaying = true;
        lastTickTime = 0;
        app.ticker.add(() => {
            tick(performance.now());
        });
    }

    function resizeApp() {
        if (!app || !background || !gameContainer) return;
        const parent = document.getElementById('pixi-container').parentElement;
        let w = parent.clientWidth;
        let h = parent.clientHeight || (w / aspectRatio);

        const ar = w / h;
        if (ar > aspectRatio) w = h * aspectRatio;
        else h = w / aspectRatio;

        app.renderer.resize(w, h);
        const scale = Math.min(w / maxWidth, h / maxHeight);
        app.stage.scale.set(scale);
        app.stage.position.set(
            (w - maxWidth * scale) / 2,
            (h - maxHeight * scale) / 2
        );
        background.width = maxWidth;
        background.height = maxHeight;
    }

    init();
})();
</script>
{% endblock %}
